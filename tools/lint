#! /usr/bin/env python3

import importlib.util
from pathlib import Path
import types
from typing import Dict, Callable, Any
import importlib.machinery
from dataclasses import dataclass
from enum import Enum, auto
from lib.lint_response import LintResponse
import logging
import json

DIR = Path(__file__).parent

class LinterMethod(Enum):
    CHECK = auto()
    FIX = auto()

Module = Any

@dataclass(frozen=True)
class LinterSpecification:
    name: str
    make_args: Callable[[Module, LinterMethod], Any]
    source_path: Path
    supported_methods: frozenset[LinterMethod]
    requires: frozenset[str] = frozenset()

class LinterManager:
    def __init__(self) -> None:
        self.specs: Dict[str, LinterSpecification] = {}
        self.modules: Dict[str, Any] = {}
        self.loaded: bool = False

    def register(self, spec: LinterSpecification):
        assert spec.name not in self.specs
        assert not self.loaded
        self.specs[spec.name] = spec

    def _load_all(self):
        if not self.loaded:
            for name, spec in self.specs.items():
                loader = importlib.machinery.SourceFileLoader(spec.name, str(spec.source_path.absolute()))
                mod = types.ModuleType(loader.name)
                loader.exec_module(mod)
                self.modules[name] = mod
        self.loaded = True

    def _run_all(self, method: LinterMethod) -> Dict[str, LintResponse]:
        self._load_all()

        responses: Dict[str, LintResponse] = {}
        job_queue = list(self.specs)

        def _add_job(name):
            if name not in job_queue and name not in responses:
                job_queue.append(name)

        while len(job_queue) > 0:
            name = job_queue.pop(0)
            spec = self.specs[name]

            if method not in spec.supported_methods:
                continue

            if not all([dep in responses and responses[dep].return_code == 0 for dep in spec.requires]):
                continue

            module = self.modules[name]
            args = spec.make_args(module, method)
            responses[name] = module.run(args)

            if responses[name].return_code == 0:
                for other_name, other_spec in self.specs.items():
                    if name in other_spec.requires:
                        _add_job(other_name)

        return responses

    def check(self) -> Dict[str, LintResponse]:
        return self._run_all(method=LinterMethod.CHECK)

    def fix(self) -> Dict[str, LintResponse]:
        return self._run_all(method=LinterMethod.FIX)

if __name__ == '__main__':
    mgr = LinterManager()
    mgr.register(LinterSpecification(
        name='include-guards',
        make_args=(
            lambda mod, method: mod.Args(
                path=DIR,
                fix=(method == LinterMethod.FIX),
                force=False,
                log_level=logging.WARN,
        )),
        source_path=DIR / 'fix-include-guards',
        supported_methods=frozenset({
            LinterMethod.FIX, LinterMethod.CHECK
        }),
        requires = frozenset()
    ))
    mgr.register(LinterSpecification(
        name='format',
        make_args=(
            lambda mod, method: mod.Args(
                path=DIR,
                fix=(method == LinterMethod.FIX),
                force=False,
                log_level=logging.WARN,
            )
        ),
        source_path=DIR / 'format',
        supported_methods=frozenset({
            LinterMethod.FIX, LinterMethod.CHECK
        })
    ))

    def handle_response_data(response: LintResponse):
        if response.json_data is not None:
            return response.json_data
        elif response.message is not None:
            return response.message
        else: 
            return None


    responses = mgr.check()
    data = {k : handle_response_data(r) for k, r in responses.items()}
    print(json.dumps(data, indent=2))
