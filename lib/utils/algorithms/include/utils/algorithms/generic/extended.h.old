#ifndef _FLEXFLOW_LIB_UTILS_ALGORITHMS_INCLUDE_UTILS_ALGORITHMS_GENERIC_EXTENDED_H
#define _FLEXFLOW_LIB_UTILS_ALGORITHMS_INCLUDE_UTILS_ALGORITHMS_GENERIC_EXTENDED_H

#include "utils/algorithms/typeclass/functor/functor.h"
#include "utils/algorithms/typeclass/monoid/monoid.h"
#include "utils/algorithms/typeclass/monoid/functions/mconcat.h"
#include "range/v3/view/concat.hpp"
#include "range/v3/range/conversion.hpp"

namespace FlexFlow {

template <typename T1, typename T2, typename Instance = default_monoid_t<T1>, typename FunctorInstance = default_functor_t<T2>>
void extend(T1 &t1, T2 const &t2) {
  static_assert(std::is_constructible_v<T1, element_type_t<T2, FunctorInstance>>);

  using A = element_type_t<T2, FunctorInstance>;
  
  T1 t2_converted = mconcat<T1, Instance>(fmap<T2, std::function<T1(A)>, FunctorInstance>(t2, [](A const &a) { return T1{a}; }));
  mappend_inplace<T1, Instance>(t1, t2_converted);
}

template <typename T1, typename Instance = default_monoid_t<T1>>
void extend(T1 &t1, std::nullopt_t const &t2) {
  return;
}

/* template <typename T1, typename T2> */
/* T1 extended(T1 const &t1, T2 const &t2) { */
/*   return ranges::views::concat( */
/*     ranges::views::all(t1), */
/*     ranges::views::all(t2) */
/*   ) | ranges::to<T1>(); */
/* } */

} // namespace FlexFlow

#endif
